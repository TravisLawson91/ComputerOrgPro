; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	C:\Users\Travis\Desktop\Computer Organization\Project\2018 08 - CS 3843 - ProjectFiles4Students\CryptoMain_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?gkey@@3PAEA					; gkey
PUBLIC	?gptrKey@@3PAEA					; gptrKey
PUBLIC	?gPassword@@3PADA				; gPassword
PUBLIC	?gPasswordHash@@3PAEA				; gPasswordHash
PUBLIC	?gptrPasswordHash@@3PAEA			; gptrPasswordHash
PUBLIC	?gdebug1@@3EA					; gdebug1
PUBLIC	?gdebug2@@3EA					; gdebug2
PUBLIC	?gfptrIn@@3PAU_iobuf@@A				; gfptrIn
PUBLIC	?gfptrOut@@3PAU_iobuf@@A			; gfptrOut
PUBLIC	?gfptrKey@@3PAU_iobuf@@A			; gfptrKey
PUBLIC	?gInFileName@@3PADA				; gInFileName
PUBLIC	?gOutFileName@@3PADA				; gOutFileName
PUBLIC	?gKeyFileName@@3PADA				; gKeyFileName
PUBLIC	?gOp@@3HA					; gOp
PUBLIC	?gNumRounds@@3HA				; gNumRounds
PUBLIC	?gEncodeTable@@3PAEA				; gEncodeTable
PUBLIC	?gDecodeTable@@3PAEA				; gDecodeTable
_BSS	SEGMENT
?gkey@@3PAEA DB	010001H DUP (?)				; gkey
	ALIGN	4

?gPasswordHash@@3PAEA DB 020H DUP (?)			; gPasswordHash
?gdebug1@@3EA DB 01H DUP (?)				; gdebug1
	ALIGN	4

?gdebug2@@3EA DB 01H DUP (?)				; gdebug2
	ALIGN	4

?gfptrIn@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrIn
?gfptrOut@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrOut
?gfptrKey@@3PAU_iobuf@@A DD 01H DUP (?)			; gfptrKey
?gInFileName@@3PADA DB 0100H DUP (?)			; gInFileName
?gOutFileName@@3PADA DB 0100H DUP (?)			; gOutFileName
?gKeyFileName@@3PADA DB 0100H DUP (?)			; gKeyFileName
?gOp@@3HA DD	01H DUP (?)				; gOp
_BSS	ENDS
msvcjmc	SEGMENT
__7C512EE2_ctype@h DB 01H
__5BEBA810_basetsd@h DB 01H
__07523DAF_corecrt_memcpy_s@h DB 01H
__9F081559_corecrt_memory@h DB 01H
__9CE3A74D_corecrt_wstring@h DB 01H
__78F4D6C6_string@h DB 01H
__F7698904_guiddef@h DB 01H
__1D5C983A_winnt@h DB 01H
__4D75C327_processthreadsapi@h DB 01H
__A1C010E7_memoryapi@h DB 01H
__3CD9AC13_winerror@h DB 01H
__7D6EA4B0_winbase@h DB 01H
__1586EFC7_winuser@h DB 01H
__ED00179D_winioctl@h DB 01H
__FE874262_stdlib@h DB 01H
__22D85348_propidl@h DB 01H
__A325E0C4_oleauto@h DB 01H
__49821EBB_stralign@h DB 01H
__320E01E0_corecrt_stdio_config@h DB 01H
__BAC7FC50_corecrt_wstdio@h DB 01H
__A3797CDC_stdio@h DB 01H
__BE076D93_corecrt_wio@h DB 01H
__CEEB45E5_corecrt_io@h DB 01H
__1E0319E4_cryptomain_initial@cpp DB 01H
msvcjmc	ENDS
_DATA	SEGMENT
?gptrKey@@3PAEA DD FLAT:?gkey@@3PAEA			; gptrKey
?gptrPasswordHash@@3PAEA DD FLAT:?gPasswordHash@@3PAEA	; gptrPasswordHash
?gPassword@@3PADA DB 'password', 00H			; gPassword
	ORG $+247
?gNumRounds@@3HA DD 01H					; gNumRounds
	ORG $+4
?gEncodeTable@@3PAEA DB 027H				; gEncodeTable
	DB	046H
	DB	017H
	DB	07H
	DB	03cH
	DB	0ffH
	DB	03fH
	DB	0d3H
	DB	04cH
	DB	0b2H
	DB	0c1H
	DB	0c3H
	DB	05fH
	DB	015H
	DB	04H
	DB	0efH
	DB	038H
	DB	0aeH
	DB	0eH
	DB	097H
	DB	02dH
	DB	04dH
	DB	0f8H
	DB	0c2H
	DB	035H
	DB	0daH
	DB	09fH
	DB	024H
	DB	043H
	DB	050H
	DB	09dH
	DB	045H
	DB	0d2H
	DB	0aH
	DB	078H
	DB	0e0H
	DB	03eH
	DB	018H
	DB	089H
	DB	062H
	DB	0c7H
	DB	07fH
	DB	093H
	DB	0ceH
	DB	0b4H
	DB	031H
	DB	07bH
	DB	0ccH
	DB	00H
	DB	0dbH
	DB	010H
	DB	092H
	DB	05dH
	DB	0f4H
	DB	077H
	DB	08aH
	DB	02cH
	DB	0a9H
	DB	034H
	DB	0faH
	DB	026H
	DB	01cH
	DB	0f6H
	DB	0a4H
	DB	095H
	DB	06cH
	DB	04bH
	DB	0c4H
	DB	09H
	DB	05aH
	DB	074H
	DB	0ecH
	DB	06aH
	DB	0afH
	DB	04aH
	DB	084H
	DB	063H
	DB	0dH
	DB	0aaH
	DB	014H
	DB	030H
	DB	016H
	DB	064H
	DB	06dH
	DB	058H
	DB	0d0H
	DB	0bbH
	DB	0d8H
	DB	075H
	DB	0e5H
	DB	02aH
	DB	09bH
	DB	041H
	DB	0c8H
	DB	08dH
	DB	0e6H
	DB	01H
	DB	0b1H
	DB	0a0H
	DB	0f3H
	DB	0ebH
	DB	09eH
	DB	069H
	DB	087H
	DB	037H
	DB	081H
	DB	048H
	DB	07cH
	DB	0a8H
	DB	0c0H
	DB	0f5H
	DB	0b7H
	DB	023H
	DB	0a3H
	DB	07eH
	DB	02eH
	DB	0e4H
	DB	01dH
	DB	056H
	DB	033H
	DB	03dH
	DB	0a5H
	DB	0e3H
	DB	0d1H
	DB	0bfH
	DB	055H
	DB	022H
	DB	0c6H
	DB	0c9H
	DB	0dfH
	DB	032H
	DB	09cH
	DB	0fdH
	DB	0d6H
	DB	03H
	DB	06H
	DB	05cH
	DB	08eH
	DB	0b0H
	DB	03bH
	DB	08cH
	DB	036H
	DB	04fH
	DB	02H
	DB	025H
	DB	07aH
	DB	0edH
	DB	07dH
	DB	0d5H
	DB	082H
	DB	011H
	DB	090H
	DB	0bH
	DB	0cdH
	DB	0b3H
	DB	0abH
	DB	02bH
	DB	053H
	DB	0b6H
	DB	054H
	DB	0a2H
	DB	0e8H
	DB	059H
	DB	072H
	DB	086H
	DB	083H
	DB	0caH
	DB	049H
	DB	06eH
	DB	040H
	DB	0bcH
	DB	061H
	DB	052H
	DB	0feH
	DB	079H
	DB	0eaH
	DB	029H
	DB	042H
	DB	088H
	DB	096H
	DB	0beH
	DB	012H
	DB	0cbH
	DB	0baH
	DB	08H
	DB	01eH
	DB	051H
	DB	02fH
	DB	044H
	DB	020H
	DB	065H
	DB	06bH
	DB	04eH
	DB	067H
	DB	0eeH
	DB	0a6H
	DB	071H
	DB	0dcH
	DB	076H
	DB	019H
	DB	0deH
	DB	0f2H
	DB	0fbH
	DB	070H
	DB	021H
	DB	0cfH
	DB	073H
	DB	068H
	DB	0e7H
	DB	0b9H
	DB	0f1H
	DB	05bH
	DB	091H
	DB	0d9H
	DB	0d4H
	DB	099H
	DB	01bH
	DB	0e1H
	DB	0f0H
	DB	0ddH
	DB	0fcH
	DB	0e2H
	DB	039H
	DB	05eH
	DB	01aH
	DB	066H
	DB	060H
	DB	0a7H
	DB	08bH
	DB	0b8H
	DB	0d7H
	DB	094H
	DB	0e9H
	DB	0acH
	DB	0c5H
	DB	09aH
	DB	0bdH
	DB	06fH
	DB	0f9H
	DB	028H
	DB	013H
	DB	05H
	DB	057H
	DB	0b5H
	DB	0cH
	DB	080H
	DB	08fH
	DB	03aH
	DB	01fH
	DB	047H
	DB	098H
	DB	0fH
	DB	0f7H
	DB	0adH
	DB	085H
	DB	0a1H
?gDecodeTable@@3PAEA DB 030H				; gDecodeTable
	DB	060H
	DB	08fH
	DB	086H
	DB	0eH
	DB	0f1H
	DB	087H
	DB	03H
	DB	0b8H
	DB	044H
	DB	021H
	DB	098H
	DB	0f4H
	DB	04dH
	DB	012H
	DB	0fbH
	DB	032H
	DB	096H
	DB	0b5H
	DB	0f0H
	DB	04fH
	DB	0dH
	DB	051H
	DB	02H
	DB	025H
	DB	0c7H
	DB	0e0H
	DB	0d8H
	DB	03dH
	DB	075H
	DB	0b9H
	DB	0f8H
	DB	0bdH
	DB	0ccH
	DB	07eH
	DB	070H
	DB	01bH
	DB	090H
	DB	03cH
	DB	00H
	DB	0efH
	DB	0b0H
	DB	05aH
	DB	09cH
	DB	038H
	DB	014H
	DB	073H
	DB	0bbH
	DB	050H
	DB	02dH
	DB	082H
	DB	077H
	DB	03aH
	DB	018H
	DB	08dH
	DB	068H
	DB	010H
	DB	0deH
	DB	0f7H
	DB	08bH
	DB	04H
	DB	078H
	DB	024H
	DB	06H
	DB	0a9H
	DB	05cH
	DB	0b1H
	DB	01cH
	DB	0bcH
	DB	01fH
	DB	01H
	DB	0f9H
	DB	06aH
	DB	0a7H
	DB	04aH
	DB	042H
	DB	08H
	DB	015H
	DB	0c0H
	DB	08eH
	DB	01dH
	DB	0baH
	DB	0acH
	DB	09dH
	DB	09fH
	DB	07dH
	DB	076H
	DB	0f2H
	DB	054H
	DB	0a2H
	DB	045H
	DB	0d3H
	DB	088H
	DB	034H
	DB	0dfH
	DB	0cH
	DB	0e2H
	DB	0abH
	DB	027H
	DB	04cH
	DB	052H
	DB	0beH
	DB	0e1H
	DB	0c1H
	DB	0cfH
	DB	066H
	DB	048H
	DB	0bfH
	DB	041H
	DB	053H
	DB	0a8H
	DB	0edH
	DB	0cbH
	DB	0c4H
	DB	0a3H
	DB	0ceH
	DB	046H
	DB	058H
	DB	0c6H
	DB	036H
	DB	022H
	DB	0aeH
	DB	091H
	DB	02eH
	DB	06bH
	DB	093H
	DB	072H
	DB	029H
	DB	0f5H
	DB	069H
	DB	095H
	DB	0a5H
	DB	04bH
	DB	0feH
	DB	0a4H
	DB	067H
	DB	0b2H
	DB	026H
	DB	037H
	DB	0e4H
	DB	08cH
	DB	05eH
	DB	089H
	DB	0f6H
	DB	097H
	DB	0d4H
	DB	033H
	DB	02aH
	DB	0e7H
	DB	040H
	DB	0b3H
	DB	013H
	DB	0faH
	DB	0d7H
	DB	0ebH
	DB	05bH
	DB	083H
	DB	01eH
	DB	065H
	DB	01aH
	DB	062H
	DB	0ffH
	DB	0a0H
	DB	071H
	DB	03fH
	DB	079H
	DB	0c3H
	DB	0e3H
	DB	06cH
	DB	039H
	DB	04eH
	DB	09bH
	DB	0e9H
	DB	0fdH
	DB	011H
	DB	049H
	DB	08aH
	DB	061H
	DB	09H
	DB	09aH
	DB	02cH
	DB	0f3H
	DB	09eH
	DB	06fH
	DB	0e5H
	DB	0d1H
	DB	0b7H
	DB	056H
	DB	0aaH
	DB	0ecH
	DB	0b4H
	DB	07cH
	DB	06dH
	DB	0aH
	DB	017H
	DB	0bH
	DB	043H
	DB	0eaH
	DB	07fH
	DB	028H
	DB	05dH
	DB	080H
	DB	0a6H
	DB	0b6H
	DB	02fH
	DB	099H
	DB	02bH
	DB	0cdH
	DB	055H
	DB	07bH
	DB	020H
	DB	07H
	DB	0d6H
	DB	094H
	DB	085H
	DB	0e6H
	DB	057H
	DB	0d5H
	DB	019H
	DB	031H
	DB	0c5H
	DB	0dbH
	DB	0c8H
	DB	081H
	DB	023H
	DB	0d9H
	DB	0ddH
	DB	07aH
	DB	074H
	DB	059H
	DB	05fH
	DB	0d0H
	DB	0a1H
	DB	0e8H
	DB	0afH
	DB	064H
	DB	047H
	DB	092H
	DB	0c2H
	DB	0fH
	DB	0daH
	DB	0d2H
	DB	0c9H
	DB	063H
	DB	035H
	DB	06eH
	DB	03eH
	DB	0fcH
	DB	016H
	DB	0eeH
	DB	03bH
	DB	0caH
	DB	0dcH
	DB	084H
	DB	0adH
	DB	05H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	?exCountLetters@@YAXPADHPAH11@Z			; exCountLetters
PUBLIC	?encryptFile@@YAHPAU_iobuf@@0@Z			; encryptFile
PUBLIC	?decryptFile@@YAHPAU_iobuf@@0@Z			; decryptFile
PUBLIC	?openInputFile@@YAPAU_iobuf@@PAD@Z		; openInputFile
PUBLIC	?openOutputFile@@YAPAU_iobuf@@PAD@Z		; openOutputFile
PUBLIC	?usage@@YAXQAPAD@Z				; usage
PUBLIC	?parseCommandLine@@YAXHQAPAD@Z			; parseCommandLine
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@ ; `string'
PUBLIC	??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@ ; `string'
PUBLIC	??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@ ; `string'
PUBLIC	??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@ ; `string'
PUBLIC	??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@ ; `string'
PUBLIC	??_C@_03BFHAFKOB@wb?$CL@			; `string'
PUBLIC	??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@ ; `string'
PUBLIC	??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@		; `string'
PUBLIC	??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@		; `string'
PUBLIC	??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ ; `string'
PUBLIC	??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@		; `string'
PUBLIC	??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ ; `string'
PUBLIC	??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@ ; `string'
PUBLIC	??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@ ; `string'
PUBLIC	??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@ ; `string'
PUBLIC	??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@ ; `string'
PUBLIC	??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@ ; `string'
PUBLIC	??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@ ; `string'
PUBLIC	??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@ ; `string'
PUBLIC	??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@ ; `string'
PUBLIC	??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@ ; `string'
PUBLIC	??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@ ; `string'
PUBLIC	??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@ ; `string'
PUBLIC	??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@ ; `string'
PUBLIC	??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@ ; `string'
PUBLIC	??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@ ; `string'
PUBLIC	??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@ ; `string'
PUBLIC	??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@ ; `string'
PUBLIC	??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@ ; `string'
PUBLIC	??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@ ; `string'
PUBLIC	??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@ ; `string'
PUBLIC	??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@ ; `string'
PUBLIC	??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@ ; `string'
PUBLIC	??_C@_04EHENEAPI@?4enc@				; `string'
PUBLIC	??_C@_04PDKEMIHM@?4dec@				; `string'
PUBLIC	??_C@_06LPALFHPD@ABCDE?$AA@			; `string'
PUBLIC	??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@ ; `string'
PUBLIC	??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@ ; `string'
PUBLIC	??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@ ; `string'
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	?sha256@@YAHPAD0KQAE@Z:PROC			; sha256
EXTRN	?encryptData@@YAHPADH@Z:PROC			; encryptData
EXTRN	?decryptData@@YAHPADH@Z:PROC			; decryptData
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@
CONST	SEGMENT
??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@ DB 'Error! L'
	DB	'ength of key file is not at least 65537.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@
CONST	SEGMENT
??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@ DB 'Error! Pas'
	DB	'sword not hashed correctly.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@
CONST	SEGMENT
??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@ DB 0aH, 0aH, 'Crypto Ord'
	DB	'er:%s', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPALFHPD@ABCDE?$AA@
CONST	SEGMENT
??_C@_06LPALFHPD@ABCDE?$AA@ DB 'ABCDE', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDKEMIHM@?4dec@
CONST	SEGMENT
??_C@_04PDKEMIHM@?4dec@ DB '.dec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHENEAPI@?4enc@
CONST	SEGMENT
??_C@_04EHENEAPI@?4enc@ DB '.enc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@
CONST	SEGMENT
??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@ DB 'Warning! U'
	DB	'sing default ''password''.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@
CONST	SEGMENT
??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@ DB 'Error! '
	DB	'No key file specified.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@
CONST	SEGMENT
??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@ DB 'Error! No'
	DB	' input file specified.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@
CONST	SEGMENT
??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@ DB 'Error! En'
	DB	'crypt or Decrypt must be specified.', 0aH, 0aH, ')', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@
CONST	SEGMENT
??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@ DB 'Error! Ill'
	DB	'egal option in argument. %s', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@
CONST	SEGMENT
??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@ DB 'Warning! E'
	DB	'ntered bad value for number of rounds. Setting it to one.', 0aH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@
CONST	SEGMENT
??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@ DB 'Error! Mus'
	DB	't enter number between 1 and 3 after ''-r''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@
CONST	SEGMENT
??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@ DB 'Error! Mu'
	DB	'st enter a password after ''-p''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@
CONST	SEGMENT
??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@ DB 'Error! Alre'
	DB	'ady specifed a password.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-k''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@
CONST	SEGMENT
??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@ DB 'Error! Al'
	DB	'ready specifed a key file.', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-o''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@
CONST	SEGMENT
??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@ DB 'Error! Alr'
	DB	'eady specifed an output file.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-d''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@
CONST	SEGMENT
??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@ DB 'Error! Alr'
	DB	'eady specifed an input file - can''t decrypt/encrypt multiple'
	DB	' files.', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@
CONST	SEGMENT
??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@ DB 'Error! Mu'
	DB	'st specify a filename after ''-e''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@
CONST	SEGMENT
??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@ DB 'Error! Alr'
	DB	'eady specifed an input file - can''t encrypt/decrypt multiple'
	DB	' files.', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@
CONST	SEGMENT
??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@ DB 'All options '
	DB	'must be preceeded by a dash ''-''', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@
CONST	SEGMENT
??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@ DB 'The order o'
	DB	'f the options is irrelevant.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@
CONST	SEGMENT
??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@ DB '-o filenam'
	DB	'e', 09H, 09H, ':name of the output file [default=''encrypted.'
	DB	'txt'' or ''decrypted.txt''', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@
CONST	SEGMENT
??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@ DB '-'
	DB	'r <#rounds>', 09H, 09H, ':number of encryption rounds (1 - 3)'
	DB	'  [default = 1]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@
CONST	SEGMENT
??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@ DB '-p passwo'
	DB	'rd', 09H, 09H, ':the password to be used for encryption [defa'
	DB	'ult=''password'']', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@
CONST	SEGMENT
??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@ DB '-d filenam'
	DB	'e', 09H, 09H, ':decrypt the specified file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@
CONST	SEGMENT
??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@ DB '-e filenam'
	DB	'e', 09H, 09H, ':encrypt the specified file', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
CONST	SEGMENT
??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ DB '%'
	DB	's -d <message_filename> -k <keyfile> -p <password> [-r <#roun'
	DB	'ds>]', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@
CONST	SEGMENT
??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@ DB 'To Decrypt:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
CONST	SEGMENT
??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@ DB '%'
	DB	's -e <message_filename> -k <keyfile> -p <password> [-r <#roun'
	DB	'ds>]', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@
CONST	SEGMENT
??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@ DB 'To Encrypt:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@
CONST	SEGMENT
??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@ DB 0aH, 0aH, 'Usage:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@
CONST	SEGMENT
??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@ DB 0aH, 0aH, 'E'
	DB	'rror - Could not open output file %s!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BFHAFKOB@wb?$CL@
CONST	SEGMENT
??_C@_03BFHAFKOB@wb?$CL@ DB 'wb+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@
CONST	SEGMENT
??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@ DB 'Aborting '
	DB	'operation - try again!', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@
CONST	SEGMENT
??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@ DB 'Error '
	DB	'- File size is zero for "%s".', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@
CONST	SEGMENT
??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@ DB 0aH, 0aH, 'E'
	DB	'rror - Could not open input file %s!', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@
CONST	SEGMENT
??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@ DB 'Error - Inp'
	DB	'ut file to decrypt is too large.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@
CONST	SEGMENT
??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@ DB 'Error -'
	DB	' Could not allocate %d bytes of memory on the heap.', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@
CONST	SEGMENT
??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@ DB 'Error - In'
	DB	'put file to encrypt is too large.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT _main
_TEXT	SEGMENT
_resulti$ = -20						; size = 4
_length$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 459  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 460  : #ifdef TEST_CODE
; 461  : 	char testData[] = "The big lazy brown FOX jumped 123 the 987 dog. Then he 8 a CHICKEN.";
; 462  : 	int numCAPS, numLow, numNonLetters;
; 463  : 	numCAPS = numLow = numNonLetters = 0;
; 464  : 	exCountLetters(testData, strlen(testData), &numCAPS, &numLow, &numNonLetters);
; 465  : 	printf("numCAPS=%d, numLow=%d, numNonLetters=%d\n", numCAPS, numLow, numNonLetters );
; 466  : 	exit(0);
; 467  : #endif
; 468  : 
; 469  : 	int length, resulti;
; 470  : 
; 471  : 	fprintf(stdout, "\n\nCrypto Order:%s\n\n", CRYPTO_ORDER);

	push	OFFSET ??_C@_06LPALFHPD@ABCDE?$AA@
	push	OFFSET ??_C@_0BE@ILNEECEA@?6?6Crypto?5Order?3?$CFs?6?6@
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 472  : 
; 473  : 	// parse command line parameters
; 474  : 	parseCommandLine(argc, argv);		// sets global variables, checks input options for errors

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argc$[ebp]
	push	ecx
	call	?parseCommandLine@@YAXHQAPAD@Z		; parseCommandLine
	add	esp, 8

; 475  : 
; 476  : 	// open the input and output files
; 477  : 	gfptrIn = openInputFile(gInFileName);

	push	OFFSET ?gInFileName@@3PADA		; gInFileName
	call	?openInputFile@@YAPAU_iobuf@@PAD@Z	; openInputFile
	add	esp, 4
	mov	DWORD PTR ?gfptrIn@@3PAU_iobuf@@A, eax	; gfptrIn

; 478  : 	gfptrKey = openInputFile(gKeyFileName);

	push	OFFSET ?gKeyFileName@@3PADA		; gKeyFileName
	call	?openInputFile@@YAPAU_iobuf@@PAD@Z	; openInputFile
	add	esp, 4
	mov	DWORD PTR ?gfptrKey@@3PAU_iobuf@@A, eax	; gfptrKey

; 479  : 	gfptrOut = openOutputFile(gOutFileName);

	push	OFFSET ?gOutFileName@@3PADA		; gOutFileName
	call	?openOutputFile@@YAPAU_iobuf@@PAD@Z	; openOutputFile
	add	esp, 4
	mov	DWORD PTR ?gfptrOut@@3PAU_iobuf@@A, eax	; gfptrOut

; 480  : 
; 481  : 	length = (size_t) strlen(gPassword);

	push	OFFSET ?gPassword@@3PADA		; gPassword
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 482  : 
; 483  : 	resulti = sha256(NULL, gPassword, length, gPasswordHash);		// get sha-256 hash of password

	push	OFFSET ?gPasswordHash@@3PAEA		; gPasswordHash
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	push	OFFSET ?gPassword@@3PADA		; gPassword
	push	0
	call	?sha256@@YAHPAD0KQAE@Z			; sha256
	add	esp, 16					; 00000010H
	mov	DWORD PTR _resulti$[ebp], eax

; 484  : 	if(resulti != 0)

	cmp	DWORD PTR _resulti$[ebp], 0
	je	SHORT $LN2@main

; 485  : 	{
; 486  : 		fprintf(stderr, "Error! Password not hashed correctly.\n\n");

	push	OFFSET ??_C@_0CI@KLALAHPJ@Error?$CB?5Password?5not?5hashed?5corr@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 487  : 		exit(-1);

	push	-1
	call	_exit
$LN2@main:

; 488  : 	}
; 489  : 
; 490  : 	length = fread(gkey, 1, 65537, gfptrKey);

	mov	eax, DWORD PTR ?gfptrKey@@3PAU_iobuf@@A	; gfptrKey
	push	eax
	push	65537					; 00010001H
	push	1
	push	OFFSET ?gkey@@3PAEA			; gkey
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _length$[ebp], eax

; 491  : 	if(length != 65537)

	cmp	DWORD PTR _length$[ebp], 65537		; 00010001H
	je	SHORT $LN3@main

; 492  : 	{
; 493  : 		fprintf(stderr, "Error! Length of key file is not at least 65537.\n\n");

	push	OFFSET ??_C@_0DD@EONHCAAK@Error?$CB?5Length?5of?5key?5file?5is?5no@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 494  : 		exit(-1);

	push	-1
	call	_exit
$LN3@main:

; 495  : 	}
; 496  : 	fclose(gfptrKey);

	mov	eax, DWORD PTR ?gfptrKey@@3PAU_iobuf@@A	; gfptrKey
	push	eax
	call	_fclose
	add	esp, 4

; 497  : 	gfptrKey = NULL;

	mov	DWORD PTR ?gfptrKey@@3PAU_iobuf@@A, 0	; gfptrKey

; 498  : 
; 499  : 	if(gOp == 1)	// encrypt

	cmp	DWORD PTR ?gOp@@3HA, 1			; gOp
	jne	SHORT $LN4@main

; 500  : 	{
; 501  : 		encryptFile(gfptrIn, gfptrOut);

	mov	eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A	; gfptrOut
	push	eax
	mov	ecx, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A	; gfptrIn
	push	ecx
	call	?encryptFile@@YAHPAU_iobuf@@0@Z		; encryptFile
	add	esp, 8

; 502  : 	}
; 503  : 	else

	jmp	SHORT $LN5@main
$LN4@main:

; 504  : 	{
; 505  : 		decryptFile(gfptrIn, gfptrOut);

	mov	eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A	; gfptrOut
	push	eax
	mov	ecx, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A	; gfptrIn
	push	ecx
	call	?decryptFile@@YAHPAU_iobuf@@0@Z		; decryptFile
	add	esp, 8
$LN5@main:

; 506  : 	}
; 507  : 
; 508  : 	fclose(gfptrIn);

	mov	eax, DWORD PTR ?gfptrIn@@3PAU_iobuf@@A	; gfptrIn
	push	eax
	call	_fclose
	add	esp, 4

; 509  : 	fclose(gfptrOut);

	mov	eax, DWORD PTR ?gfptrOut@@3PAU_iobuf@@A	; gfptrOut
	push	eax
	call	_fclose
	add	esp, 4

; 510  : 	return;
; 511  : } // main

	jmp	SHORT $LN8@main
$LN6@main:
	jmp	SHORT $LN7@main
$LN8@main:
	xor	eax, eax
$LN7@main:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?parseCommandLine@@YAXHQAPAD@Z
_TEXT	SEGMENT
_x$1 = -92						; size = 4
_err_flag$ = -77					; size = 1
_p_flag$ = -65						; size = 1
_k_flag$ = -53						; size = 1
_o_flag$ = -41						; size = 1
_i_flag$ = -29						; size = 1
_ch$ = -17						; size = 1
_cnt$ = -8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
?parseCommandLine@@YAXHQAPAD@Z PROC			; parseCommandLine, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 274  : 	int cnt;
; 275  : 	char ch;
; 276  : 	bool i_flag, o_flag, k_flag, p_flag, err_flag;
; 277  : 
; 278  : 	i_flag = k_flag = false;				// these must be true in order to exit this function

	mov	BYTE PTR _k_flag$[ebp], 0
	mov	al, BYTE PTR _k_flag$[ebp]
	mov	BYTE PTR _i_flag$[ebp], al

; 279  : 	err_flag = p_flag = o_flag = false;		// these will generate different actions

	mov	BYTE PTR _o_flag$[ebp], 0
	mov	al, BYTE PTR _o_flag$[ebp]
	mov	BYTE PTR _p_flag$[ebp], al
	mov	cl, BYTE PTR _p_flag$[ebp]
	mov	BYTE PTR _err_flag$[ebp], cl

; 280  : 
; 281  : 	cnt = 1;	// skip program name

	mov	DWORD PTR _cnt$[ebp], 1
$LN2@parseComma:

; 282  : 	while(cnt < argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jge	$LN3@parseComma

; 283  : 	{
; 284  : 		ch = *argv[cnt];

	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _ch$[ebp], al

; 285  : 		if(ch != '-')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 45					; 0000002dH
	je	SHORT $LN4@parseComma

; 286  : 		{
; 287  : 			fprintf(stderr, "All options must be preceeded by a dash '-'\n\n");

	push	OFFSET ??_C@_0CO@BHBEBKEC@All?5options?5must?5be?5preceeded?5b@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 288  : 			usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN4@parseComma:

; 289  : 		}
; 290  : 
; 291  : 		ch = *(argv[cnt]+1);

	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _ch$[ebp], al

; 292  : 		if(0)

	xor	eax, eax
	je	SHORT $LN5@parseComma
	jmp	$LN6@parseComma
$LN5@parseComma:

; 293  : 		{
; 294  : 		}
; 295  : 
; 296  : 		else if(ch == 'e' || ch == 'E')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 101				; 00000065H
	je	SHORT $LN9@parseComma
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 69					; 00000045H
	jne	$LN7@parseComma
$LN9@parseComma:

; 297  : 		{
; 298  : 			if(i_flag == true || gOp != 0)

	movzx	eax, BYTE PTR _i_flag$[ebp]
	cmp	eax, 1
	je	SHORT $LN11@parseComma
	cmp	DWORD PTR ?gOp@@3HA, 0			; gOp
	je	SHORT $LN10@parseComma
$LN11@parseComma:

; 299  : 			{
; 300  : 				fprintf(stderr, "Error! Already specifed an input file - can't encrypt/decrypt multiple files.\n\n");

	push	OFFSET ??_C@_0FA@LMDBBGLK@Error?$CB?5Already?5specifed?5an?5inpu@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 301  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN10@parseComma:

; 302  : 			}
; 303  : 
; 304  : 			i_flag = true;

	mov	BYTE PTR _i_flag$[ebp], 1

; 305  : 			cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 306  : 			if(cnt >= argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jl	SHORT $LN12@parseComma

; 307  : 			{
; 308  : 				fprintf(stderr, "Error! Must specify a filename after '-e'\n\n");

	push	OFFSET ??_C@_0CM@IFNFECJC@Error?$CB?5Must?5specify?5a?5filename?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 309  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN12@parseComma:

; 310  : 			}
; 311  : 
; 312  : 			strncpy(gInFileName, argv[cnt], 256);

	push	256					; 00000100H
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ?gInFileName@@3PADA		; gInFileName
	call	_strncpy
	add	esp, 12					; 0000000cH

; 313  : 			gOp = 1;	// encrypt

	mov	DWORD PTR ?gOp@@3HA, 1			; gOp
	jmp	$LN6@parseComma
$LN7@parseComma:

; 314  : 		}
; 315  : 
; 316  : 		else if(ch == 'd' || ch == 'D')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 100				; 00000064H
	je	SHORT $LN15@parseComma
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 68					; 00000044H
	jne	$LN13@parseComma
$LN15@parseComma:

; 317  : 		{
; 318  : 			if(i_flag == true || gOp != 0)

	movzx	eax, BYTE PTR _i_flag$[ebp]
	cmp	eax, 1
	je	SHORT $LN17@parseComma
	cmp	DWORD PTR ?gOp@@3HA, 0			; gOp
	je	SHORT $LN16@parseComma
$LN17@parseComma:

; 319  : 			{
; 320  : 				fprintf(stderr, "Error! Already specifed an input file - can't decrypt/encrypt multiple files.\n\n");

	push	OFFSET ??_C@_0FA@FBLKPEDD@Error?$CB?5Already?5specifed?5an?5inpu@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 321  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN16@parseComma:

; 322  : 			}
; 323  : 
; 324  : 			i_flag = true;

	mov	BYTE PTR _i_flag$[ebp], 1

; 325  : 			cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 326  : 			if(cnt >= argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jl	SHORT $LN18@parseComma

; 327  : 			{
; 328  : 				fprintf(stderr, "Error! Must specify a filename after '-d'\n\n");

	push	OFFSET ??_C@_0CM@LILFGLCC@Error?$CB?5Must?5specify?5a?5filename?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 329  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN18@parseComma:

; 330  : 			}
; 331  : 
; 332  : 			strncpy(gInFileName, argv[cnt], 256);

	push	256					; 00000100H
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ?gInFileName@@3PADA		; gInFileName
	call	_strncpy
	add	esp, 12					; 0000000cH

; 333  : 			gOp = 2;	// decrypt

	mov	DWORD PTR ?gOp@@3HA, 2			; gOp
	jmp	$LN6@parseComma
$LN13@parseComma:

; 334  : 		}
; 335  : 
; 336  : 		else if(ch == 'o' || ch == 'O')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 111				; 0000006fH
	je	SHORT $LN21@parseComma
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 79					; 0000004fH
	jne	$LN19@parseComma
$LN21@parseComma:

; 337  : 		{
; 338  : 			if(o_flag == true)

	movzx	eax, BYTE PTR _o_flag$[ebp]
	cmp	eax, 1
	jne	SHORT $LN22@parseComma

; 339  : 			{
; 340  : 				fprintf(stderr, "Error! Already specifed an output file.\n\n");

	push	OFFSET ??_C@_0CK@OMLLAEKC@Error?$CB?5Already?5specifed?5an?5outp@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 341  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN22@parseComma:

; 342  : 			}
; 343  : 			o_flag = true;

	mov	BYTE PTR _o_flag$[ebp], 1

; 344  : 			cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 345  : 			if(cnt >= argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jl	SHORT $LN23@parseComma

; 346  : 			{
; 347  : 				fprintf(stderr, "Error! Must specify a filename after '-o'\n\n");

	push	OFFSET ??_C@_0CM@MPGFFKDD@Error?$CB?5Must?5specify?5a?5filename?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 348  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN23@parseComma:

; 349  : 			}
; 350  : 			strncpy(gOutFileName, argv[cnt], 256);

	push	256					; 00000100H
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ?gOutFileName@@3PADA		; gOutFileName
	call	_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN6@parseComma
$LN19@parseComma:

; 351  : 		}
; 352  : 
; 353  : 		else if(ch == 'k' || ch == 'K')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 107				; 0000006bH
	je	SHORT $LN26@parseComma
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 75					; 0000004bH
	jne	$LN24@parseComma
$LN26@parseComma:

; 354  : 		{
; 355  : 			if(k_flag == true)

	movzx	eax, BYTE PTR _k_flag$[ebp]
	cmp	eax, 1
	jne	SHORT $LN27@parseComma

; 356  : 			{
; 357  : 				fprintf(stderr, "Error! Already specifed a key file.\n\n");

	push	OFFSET ??_C@_0CG@EICJBIPF@Error?$CB?5Already?5specifed?5a?5key?5f@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 358  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN27@parseComma:

; 359  : 			}
; 360  : 			k_flag = true;

	mov	BYTE PTR _k_flag$[ebp], 1

; 361  : 			cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 362  : 			if(cnt >= argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jl	SHORT $LN28@parseComma

; 363  : 			{
; 364  : 				fprintf(stderr, "Error! Must specify a filename after '-k'\n\n");

	push	OFFSET ??_C@_0CM@DKOFPMPD@Error?$CB?5Must?5specify?5a?5filename?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 365  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN28@parseComma:

; 366  : 			}
; 367  : 			strncpy(gKeyFileName, argv[cnt], 256);

	push	256					; 00000100H
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ?gKeyFileName@@3PADA		; gKeyFileName
	call	_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN6@parseComma
$LN24@parseComma:

; 368  : 		}
; 369  : 
; 370  : 		else if(ch == 'p' || ch == 'P')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 112				; 00000070H
	je	SHORT $LN31@parseComma
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 80					; 00000050H
	jne	$LN29@parseComma
$LN31@parseComma:

; 371  : 		{
; 372  : 			if(p_flag == true)

	movzx	eax, BYTE PTR _p_flag$[ebp]
	cmp	eax, 1
	jne	SHORT $LN32@parseComma

; 373  : 			{
; 374  : 				fprintf(stderr, "Error! Already specifed a password.\n\n");

	push	OFFSET ??_C@_0CG@OPKIBCL@Error?$CB?5Already?5specifed?5a?5passw@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 375  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN32@parseComma:

; 376  : 			}
; 377  : 			p_flag = true;

	mov	BYTE PTR _p_flag$[ebp], 1

; 378  : 			cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 379  : 			if(cnt >= argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jl	SHORT $LN33@parseComma

; 380  : 			{
; 381  : 				fprintf(stderr, "Error! Must enter a password after '-p'\n\n");

	push	OFFSET ??_C@_0CK@LDPPFIPG@Error?$CB?5Must?5enter?5a?5password?5af@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 382  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN33@parseComma:

; 383  : 			}
; 384  : 			strncpy(gPassword, argv[cnt], 256);

	push	256					; 00000100H
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ?gPassword@@3PADA		; gPassword
	call	_strncpy
	add	esp, 12					; 0000000cH
	jmp	$LN6@parseComma
$LN29@parseComma:

; 385  : 		}
; 386  : 
; 387  : 		else if(ch == 'r' || ch == 'R')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 114				; 00000072H
	je	SHORT $LN36@parseComma
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 82					; 00000052H
	jne	SHORT $LN34@parseComma
$LN36@parseComma:

; 388  : 		{
; 389  : 			int x;
; 390  : 
; 391  : 			cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 392  : 			if(cnt >= argc)

	mov	eax, DWORD PTR _cnt$[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jl	SHORT $LN37@parseComma

; 393  : 			{
; 394  : 				fprintf(stderr, "Error! Must enter number between 1 and 3 after '-r'\n\n");

	push	OFFSET ??_C@_0DG@KLPKKKEI@Error?$CB?5Must?5enter?5number?5betwee@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 395  : 				usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN37@parseComma:

; 396  : 			}
; 397  : 			x = atoi(argv[cnt]);

	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _x$1[ebp], eax

; 398  : 			if(x < 1 || x > 3)

	cmp	DWORD PTR _x$1[ebp], 1
	jl	SHORT $LN39@parseComma
	cmp	DWORD PTR _x$1[ebp], 3
	jle	SHORT $LN38@parseComma
$LN39@parseComma:

; 399  : 			{
; 400  : 				fprintf(stderr, "Warning! Entered bad value for number of rounds. Setting it to one.\n\n");

	push	OFFSET ??_C@_0EG@DAMCJAK@Warning?$CB?5Entered?5bad?5value?5for?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 401  : 				x = 1;

	mov	DWORD PTR _x$1[ebp], 1
$LN38@parseComma:

; 402  : 			}
; 403  : 			gNumRounds = x;

	mov	eax, DWORD PTR _x$1[ebp]
	mov	DWORD PTR ?gNumRounds@@3HA, eax		; gNumRounds

; 404  : 		}
; 405  : 
; 406  : 		else

	jmp	SHORT $LN6@parseComma
$LN34@parseComma:

; 407  : 		{
; 408  : 			fprintf(stderr, "Error! Illegal option in argument. %s\n\n", argv[cnt]);

	mov	eax, DWORD PTR _cnt$[ebp]
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_0CI@KGFPEMBM@Error?$CB?5Illegal?5option?5in?5argume@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 409  : 			usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN6@parseComma:

; 410  : 		}
; 411  : 
; 412  : 		cnt++;

	mov	eax, DWORD PTR _cnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _cnt$[ebp], eax

; 413  : 	} // end while

	jmp	$LN2@parseComma
$LN3@parseComma:

; 414  : 
; 415  : 	if(gOp == 0)

	cmp	DWORD PTR ?gOp@@3HA, 0			; gOp
	jne	SHORT $LN40@parseComma

; 416  : 	{
; 417  : 		fprintf(stderr, "Error! Encrypt or Decrypt must be specified.\n\n)");

	push	OFFSET ??_C@_0DA@HLBMPEJP@Error?$CB?5Encrypt?5or?5Decrypt?5must?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 418  : 		err_flag = true;

	mov	BYTE PTR _err_flag$[ebp], 1
$LN40@parseComma:

; 419  : 	}
; 420  : 
; 421  : 	if(i_flag == false)

	movzx	eax, BYTE PTR _i_flag$[ebp]
	test	eax, eax
	jne	SHORT $LN41@parseComma

; 422  : 	{
; 423  : 		fprintf(stderr, "Error! No input file specified.\n\n");

	push	OFFSET ??_C@_0CC@GEEGHLPK@Error?$CB?5No?5input?5file?5specified?4@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 424  : 		err_flag = true;

	mov	BYTE PTR _err_flag$[ebp], 1
$LN41@parseComma:

; 425  : 	}
; 426  : 
; 427  : 	if(k_flag == false)

	movzx	eax, BYTE PTR _k_flag$[ebp]
	test	eax, eax
	jne	SHORT $LN42@parseComma

; 428  : 	{
; 429  : 		fprintf(stderr, "Error! No key file specified.\n\n");

	push	OFFSET ??_C@_0CA@JJGKKPID@Error?$CB?5No?5key?5file?5specified?4?6?6@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 430  : 		err_flag = true;

	mov	BYTE PTR _err_flag$[ebp], 1
$LN42@parseComma:

; 431  : 	}
; 432  : 
; 433  : 	if(p_flag == false)

	movzx	eax, BYTE PTR _p_flag$[ebp]
	test	eax, eax
	jne	SHORT $LN43@parseComma

; 434  : 	{
; 435  : 		fprintf(stderr, "Warning! Using default 'password'.\n\n");

	push	OFFSET ??_C@_0CF@NMMOLMAM@Warning?$CB?5Using?5default?5?8passwor@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8
$LN43@parseComma:

; 436  : 	}
; 437  : 
; 438  : 	if(o_flag == false && err_flag == false)	// no need to do this if we have errors

	movzx	eax, BYTE PTR _o_flag$[ebp]
	test	eax, eax
	jne	SHORT $LN44@parseComma
	movzx	eax, BYTE PTR _err_flag$[ebp]
	test	eax, eax
	jne	SHORT $LN44@parseComma

; 439  : 	{
; 440  : 		strcpy(gOutFileName, gInFileName);

	push	OFFSET ?gInFileName@@3PADA		; gInFileName
	push	OFFSET ?gOutFileName@@3PADA		; gOutFileName
	call	_strcpy
	add	esp, 8

; 441  : 		if(gOp == 1)	// encrypt

	cmp	DWORD PTR ?gOp@@3HA, 1			; gOp
	jne	SHORT $LN45@parseComma

; 442  : 		{
; 443  : 			strcat(gOutFileName, ".enc");

	push	OFFSET ??_C@_04EHENEAPI@?4enc@
	push	OFFSET ?gOutFileName@@3PADA		; gOutFileName
	call	_strcat
	add	esp, 8
$LN45@parseComma:

; 444  : 		}
; 445  : 		if(gOp == 2)	// decrypt

	cmp	DWORD PTR ?gOp@@3HA, 2			; gOp
	jne	SHORT $LN44@parseComma

; 446  : 		{
; 447  : 			strcat(gOutFileName, ".dec");

	push	OFFSET ??_C@_04PDKEMIHM@?4dec@
	push	OFFSET ?gOutFileName@@3PADA		; gOutFileName
	call	_strcat
	add	esp, 8
$LN44@parseComma:

; 448  : 		}
; 449  : 	}
; 450  : 
; 451  : 	if(err_flag)

	movzx	eax, BYTE PTR _err_flag$[ebp]
	test	eax, eax
	je	SHORT $LN1@parseComma

; 452  : 	{
; 453  : 		usage(argv);

	mov	eax, DWORD PTR _argv$[ebp]
	push	eax
	call	?usage@@YAXQAPAD@Z			; usage
	add	esp, 4
$LN1@parseComma:

; 454  : 	}
; 455  : 	return;
; 456  : } // parseCommandLine

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?parseCommandLine@@YAXHQAPAD@Z ENDP			; parseCommandLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?usage@@YAXQAPAD@Z
_TEXT	SEGMENT
_argv$ = 8						; size = 4
?usage@@YAXQAPAD@Z PROC					; usage, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 255  : 	printf("\n\nUsage:\n\n");

	push	OFFSET ??_C@_0L@HKODOBAD@?6?6Usage?3?6?6@
	call	_printf
	add	esp, 4

; 256  : 
; 257  : 	printf("To Encrypt:\n");

	push	OFFSET ??_C@_0N@MOPCGLHN@To?5Encrypt?3?6@
	call	_printf
	add	esp, 4

; 258  : 	printf("%s -e <message_filename> -k <keyfile> -p <password> [-r <#rounds>]\n\n", argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0EF@JJIJOCMP@?$CFs?5?9e?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
	call	_printf
	add	esp, 8

; 259  : 
; 260  : 	printf("To Decrypt:\n");

	push	OFFSET ??_C@_0N@KDGFJOJO@To?5Decrypt?3?6@
	call	_printf
	add	esp, 4

; 261  : 	printf("%s -d <message_filename> -k <keyfile> -p <password> [-r <#rounds>]\n\n", argv[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET ??_C@_0EF@BJGDLACJ@?$CFs?5?9d?5?$DMmessage_filename?$DO?5?9k?5?$DMke@
	call	_printf
	add	esp, 8

; 262  : 
; 263  : 	printf("-e filename		:encrypt the specified file\n");

	push	OFFSET ??_C@_0CK@PGOBLBKL@?9e?5filename?7?7?3encrypt?5the?5speci@
	call	_printf
	add	esp, 4

; 264  : 	printf("-d filename		:decrypt the specified file\n");

	push	OFFSET ??_C@_0CK@GOFFCHFO@?9d?5filename?7?7?3decrypt?5the?5speci@
	call	_printf
	add	esp, 4

; 265  : 	printf("-p password		:the password to be used for encryption [default='password']\n");

	push	OFFSET ??_C@_0EL@OBNDFCCB@?9p?5password?7?7?3the?5password?5to?5b@
	call	_printf
	add	esp, 4

; 266  : 	printf("-r <#rounds>		:number of encryption rounds (1 - 3)  [default = 1]\n");

	push	OFFSET ??_C@_0ED@MAGAAIDD@?9r?5?$DM?$CDrounds?$DO?7?7?3number?5of?5encryp@
	call	_printf
	add	esp, 4

; 267  : 	printf("-o filename		:name of the output file [default='encrypted.txt' or 'decrypted.txt'\n\n");

	push	OFFSET ??_C@_0FE@LAODCPP@?9o?5filename?7?7?3name?5of?5the?5outpu@
	call	_printf
	add	esp, 4

; 268  : 	printf("The order of the options is irrelevant.\n\n");

	push	OFFSET ??_C@_0CK@IPLMHCJC@The?5order?5of?5the?5options?5is?5irr@
	call	_printf
	add	esp, 4

; 269  : 	exit(0);

	push	0
	call	_exit
$LN2@usage:

; 270  : } // usage

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?usage@@YAXQAPAD@Z ENDP					; usage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?openOutputFile@@YAPAU_iobuf@@PAD@Z
_TEXT	SEGMENT
_fptr$ = -8						; size = 4
_filename$ = 8						; size = 4
?openOutputFile@@YAPAU_iobuf@@PAD@Z PROC		; openOutputFile, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 241  : 	FILE *fptr;
; 242  : 
; 243  : 	fptr = fopen(filename, "wb+");

	push	OFFSET ??_C@_03BFHAFKOB@wb?$CL@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fptr$[ebp], eax

; 244  : 	if(fptr == NULL)

	cmp	DWORD PTR _fptr$[ebp], 0
	jne	SHORT $LN2@openOutput

; 245  : 	{
; 246  : 		fprintf(stderr, "\n\nError - Could not open output file %s!\n\n", filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@DAJOHFLE@?6?6Error?5?9?5Could?5not?5open?5output@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 247  : 		exit(-1);

	push	-1
	call	_exit
$LN2@openOutput:

; 248  : 	}
; 249  : 	return fptr;

	mov	eax, DWORD PTR _fptr$[ebp]
$LN3@openOutput:

; 250  : } // openOutputFile

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?openOutputFile@@YAPAU_iobuf@@PAD@Z ENDP		; openOutputFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?openInputFile@@YAPAU_iobuf@@PAD@Z
_TEXT	SEGMENT
_sz$ = -20						; size = 4
_fptr$ = -8						; size = 4
_filename$ = 8						; size = 4
?openInputFile@@YAPAU_iobuf@@PAD@Z PROC			; openInputFile, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 214  : 	FILE *fptr;
; 215  : 	long sz;
; 216  : 
; 217  : 	fptr = fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fptr$[ebp], eax

; 218  : 	if(fptr == NULL)

	cmp	DWORD PTR _fptr$[ebp], 0
	jne	SHORT $LN2@openInputF

; 219  : 	{
; 220  : 		fprintf(stderr, "\n\nError - Could not open input file %s!\n\n", filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CK@CDMOMEJ@?6?6Error?5?9?5Could?5not?5open?5input?5@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 221  : 		exit(-1);

	push	-1
	call	_exit
$LN2@openInputF:

; 222  : 	}
; 223  : 
; 224  : 	fseek(fptr, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fptr$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 225  : 	sz = ftell(fptr);

	mov	eax, DWORD PTR _fptr$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _sz$[ebp], eax

; 226  : 	fseek(fptr, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fptr$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 227  : 
; 228  : 	if(sz == 0)

	cmp	DWORD PTR _sz$[ebp], 0
	jne	SHORT $LN3@openInputF

; 229  : 	{
; 230  : 		fprintf(stderr, "Error - File size is zero for \"%s\".\n\n", filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	push	OFFSET ??_C@_0CG@NACGJJHN@Error?5?9?5File?5size?5is?5zero?5for?5?$CC@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 231  : 		fprintf(stderr, "Aborting operation - try again!\n\n");

	push	OFFSET ??_C@_0CC@ECEBOFML@Aborting?5operation?5?9?5try?5again?$CB@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 232  : 		fclose(fptr);

	mov	eax, DWORD PTR _fptr$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 233  : 		exit(0);

	push	0
	call	_exit
$LN3@openInputF:

; 234  : 	}
; 235  : 
; 236  : 	return fptr;

	mov	eax, DWORD PTR _fptr$[ebp]
$LN4@openInputF:

; 237  : } // openInputFile

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?openInputFile@@YAPAU_iobuf@@PAD@Z ENDP			; openInputFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?decryptFile@@YAHPAU_iobuf@@0@Z
_TEXT	SEGMENT
_filesize$ = -20					; size = 4
_buffer$ = -8						; size = 4
_fptrIn$ = 8						; size = 4
_fptrOut$ = 12						; size = 4
?decryptFile@@YAHPAU_iobuf@@0@Z PROC			; decryptFile, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 182  : 	char *buffer;
; 183  : 	unsigned int filesize;
; 184  : 
; 185  : 	fseek(fptrIn, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 186  : 	filesize = ftell(fptrIn);

	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _filesize$[ebp], eax

; 187  : 	fseek(fptrIn, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 188  : 
; 189  : 	if(filesize > 0x1000000)					// 16 MB, file too large

	cmp	DWORD PTR _filesize$[ebp], 16777216	; 01000000H
	jbe	SHORT $LN2@decryptFil

; 190  : 	{
; 191  : 		fprintf(stderr, "Error - Input file to decrypt is too large.\n\n");

	push	OFFSET ??_C@_0CO@NGFEABL@Error?5?9?5Input?5file?5to?5decrypt?5i@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 192  : 		return -1;

	or	eax, -1
	jmp	$LN1@decryptFil
$LN2@decryptFil:

; 193  : 	}
; 194  : 
; 195  : 	// use the password hash to encrypt
; 196  : 	buffer = (char *) malloc(filesize);

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _buffer$[ebp], eax

; 197  : 	if(buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN3@decryptFil

; 198  : 	{
; 199  : 		fprintf(stderr, "Error - Could not allocate %d bytes of memory on the heap.\n\n", filesize);

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 200  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@decryptFil
$LN3@decryptFil:

; 201  : 	}
; 202  : 
; 203  : 	fread(buffer, 1, filesize, fptrIn);	// read entire file

	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 204  : 	decryptData(buffer, filesize);

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?decryptData@@YAHPADH@Z			; decryptData
	add	esp, 8

; 205  : 	fwrite(buffer, 1, filesize, fptrOut);

	mov	eax, DWORD PTR _fptrOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 206  : 	free(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 207  : 
; 208  : 	return 0;

	xor	eax, eax
$LN1@decryptFil:

; 209  : } // decryptFile

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?decryptFile@@YAHPAU_iobuf@@0@Z ENDP			; decryptFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?encryptFile@@YAHPAU_iobuf@@0@Z
_TEXT	SEGMENT
_filesize$ = -20					; size = 4
_buffer$ = -8						; size = 4
_fptrIn$ = 8						; size = 4
_fptrOut$ = 12						; size = 4
?encryptFile@@YAHPAU_iobuf@@0@Z PROC			; encryptFile, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1E0319E4_cryptomain_initial@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 149  : 	char *buffer;
; 150  : 	unsigned int filesize;
; 151  : 
; 152  : 	fseek(fptrIn, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 153  : 	filesize = ftell(fptrIn);

	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _filesize$[ebp], eax

; 154  : 	fseek(fptrIn, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 155  : 
; 156  : 	if(filesize > 0x1000000)					// 16 MB, file too large

	cmp	DWORD PTR _filesize$[ebp], 16777216	; 01000000H
	jbe	SHORT $LN2@encryptFil

; 157  : 	{
; 158  : 		fprintf(stderr, "Error - Input file to encrypt is too large.\n\n");

	push	OFFSET ??_C@_0CO@PKBMFPCH@Error?5?9?5Input?5file?5to?5encrypt?5i@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 159  : 		return -1;

	or	eax, -1
	jmp	$LN1@encryptFil
$LN2@encryptFil:

; 160  : 	}
; 161  : 
; 162  : 	// use the password hash to encrypt
; 163  : 	buffer = (char *) malloc(filesize);

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _buffer$[ebp], eax

; 164  : 	if(buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN3@encryptFil

; 165  : 	{
; 166  : 		fprintf(stderr, "Error - Could not allocate %d bytes of memory on the heap.\n\n", filesize);

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@DPPAPLJB@Error?5?9?5Could?5not?5allocate?5?$CFd?5b@
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 167  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN1@encryptFil
$LN3@encryptFil:

; 168  : 	}
; 169  : 
; 170  : 	fread(buffer, 1, filesize, fptrIn);	// read entire file

	mov	eax, DWORD PTR _fptrIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 171  : 	encryptData(buffer, filesize);

	mov	eax, DWORD PTR _filesize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	?encryptData@@YAHPADH@Z			; encryptData
	add	esp, 8

; 172  : 	fwrite(buffer, 1, filesize, fptrOut);

	mov	eax, DWORD PTR _fptrOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filesize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 173  : 	free(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 174  : 
; 175  : 	return 0;

	xor	eax, eax
$LN1@encryptFil:

; 176  : } // encryptFile

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?encryptFile@@YAHPAU_iobuf@@0@Z ENDP			; encryptFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\cryptomain_initial.cpp
;	COMDAT ?exCountLetters@@YAXPADHPAH11@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
_numC$ = 16						; size = 4
_numL$ = 20						; size = 4
_numO$ = 24						; size = 4
?exCountLetters@@YAXPADHPAH11@Z PROC			; exCountLetters, COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 69   : 	__asm {
; 70   : 		cld;					// 

	cld

; 71   : 		push esi;				// 

	push	esi

; 72   : 		push ecx;				// 

	push	ecx

; 73   : 		push ebx;

	push	ebx

; 74   : 		mov esi,data;			// 

	mov	esi, DWORD PTR _data$[ebp]

; 75   : 		mov ecx, dataLength;	// 

	mov	ecx, DWORD PTR _dataLength$[ebp]
$LOOP_X1$3:

; 76   : 
; 77   : LOOP_X1:
; 78   : 		lodsb;					// 

	lodsb

; 79   : 		mov bl,al				// 

	mov	bl, al

; 80   : 		push eax;				// 

	push	eax

; 81   : 		call isLetter;			// function returns a 1 in al if the character passed in is a letter, otherwise al = 0

	call	$isLetter$4

; 82   : 		add esp,4				// 

	add	esp, 4

; 83   : 		test al,al;				// 

	test	al, al

; 84   : 		je lbl_OTHER;			// 

	je	SHORT $lbl_OTHER$5

; 85   : 
; 86   : 		mov al,bl				// 

	mov	al, bl

; 87   : 		and al,0x20;			// already know it's a letter, if al == 0, then CAP

	and	al, 32					; 00000020H

; 88   : 		je lbl_CAP;

	je	SHORT $lbl_CAP$6

; 89   : 		
; 90   : 		mov	ebx,numL;			// 

	mov	ebx, DWORD PTR _numL$[ebp]

; 91   : 		add [ebx],1;			// 

	add	BYTE PTR [ebx], 1

; 92   : 		jmp lbl_NEXT;			// 

	jmp	SHORT $lbl_NEXT$7
$lbl_CAP$6:

; 93   : 
; 94   : lbl_CAP:
; 95   : 		mov ebx,numC;			// 

	mov	ebx, DWORD PTR _numC$[ebp]

; 96   : 		add [ebx],1;			// 

	add	BYTE PTR [ebx], 1

; 97   : 		jmp lbl_NEXT;			// 

	jmp	SHORT $lbl_NEXT$7
$lbl_OTHER$5:

; 98   : 
; 99   : lbl_OTHER:
; 100  : 		mov ebx,numO			// 

	mov	ebx, DWORD PTR _numO$[ebp]

; 101  : 		add [ebx],1				// 

	add	BYTE PTR [ebx], 1
$lbl_NEXT$7:

; 102  : lbl_NEXT:
; 103  : 		dec ecx;				// 

	dec	ecx

; 104  : 		jne LOOP_X1;			// 

	jne	SHORT $LOOP_X1$3

; 105  : 
; 106  : 		pop ebx;				// 

	pop	ebx

; 107  : 		pop ecx;				// 

	pop	ecx

; 108  : 		pop esi;				// 

	pop	esi

; 109  : 		jmp EXIT_C_EXAMPLE;		// let C handle whatever it did upon entering this function

	jmp	SHORT $EXIT_C_EXAMPLE$8
$isLetter$4:

; 110  : 
; 111  : isLetter:
; 112  : 		push ebp;				// 

	push	ebp

; 113  : 		mov ebp,esp;			// 

	mov	ebp, esp

; 114  : 		mov al,[ebp+8];			// 

	mov	al, BYTE PTR [ebp+8]

; 115  : 		cmp al,0x40;			// 

	cmp	al, 64					; 00000040H

; 116  : 		ja lbl_CHK_ZU;			// check Uppercase 'Z'

	ja	SHORT $lbl_CHK_ZU$9
$lbl_RET_FALSE$10:

; 117  : 
; 118  : lbl_RET_FALSE:
; 119  : 		xor eax,eax;			// 

	xor	eax, eax
$lbl_RET$11:

; 120  : lbl_RET:
; 121  : 		mov esp,ebp;			// 

	mov	esp, ebp

; 122  : 		pop ebp;				// 

	pop	ebp

; 123  : 		ret;					// 

	ret	0
$lbl_RET_TRUE$12:

; 124  : 
; 125  : lbl_RET_TRUE:
; 126  : 		mov eax,1;				// 

	mov	eax, 1

; 127  : 		jmp lbl_RET;			// 

	jmp	SHORT $lbl_RET$11
$lbl_CHK_ZU$9:

; 128  : 
; 129  : lbl_CHK_ZU:
; 130  : 		cmp al,0x5B;			// 

	cmp	al, 91					; 0000005bH

; 131  : 		jb lbl_RET_TRUE;		// 

	jb	SHORT $lbl_RET_TRUE$12

; 132  : 
; 133  : 		cmp al,0x61;			// 

	cmp	al, 97					; 00000061H

; 134  : 		jb lbl_RET_FALSE;		// check lowercase 'z'

	jb	SHORT $lbl_RET_FALSE$10

; 135  : 
; 136  : 		cmp al,0x7A;			// 

	cmp	al, 122					; 0000007aH

; 137  : 		jbe lbl_RET_TRUE;		// 

	jbe	SHORT $lbl_RET_TRUE$12

; 138  : 		jmp lbl_RET_FALSE;		// 

	jmp	SHORT $lbl_RET_FALSE$10
$EXIT_C_EXAMPLE$8:

; 139  : 
; 140  : 	} // end assembly block
; 141  : 
; 142  : EXIT_C_EXAMPLE:					// 
; 143  : 	return;
; 144  : } // exCountLetters

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?exCountLetters@@YAXPADHPAH11@Z ENDP			; exCountLetters
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A3797CDC_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A3797CDC_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A3797CDC_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 85   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __320E01E0_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END

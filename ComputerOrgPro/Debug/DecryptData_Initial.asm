; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	C:\Users\Travis\Desktop\Computer Organization\Project\2018 08 - CS 3843 - ProjectFiles4Students\DecryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7C512EE2_ctype@h DB 01H
__5BEBA810_basetsd@h DB 01H
__07523DAF_corecrt_memcpy_s@h DB 01H
__9F081559_corecrt_memory@h DB 01H
__9CE3A74D_corecrt_wstring@h DB 01H
__78F4D6C6_string@h DB 01H
__F7698904_guiddef@h DB 01H
__1D5C983A_winnt@h DB 01H
__4D75C327_processthreadsapi@h DB 01H
__A1C010E7_memoryapi@h DB 01H
__3CD9AC13_winerror@h DB 01H
__7D6EA4B0_winbase@h DB 01H
__1586EFC7_winuser@h DB 01H
__ED00179D_winioctl@h DB 01H
__FE874262_stdlib@h DB 01H
__22D85348_propidl@h DB 01H
__A325E0C4_oleauto@h DB 01H
__49821EBB_stralign@h DB 01H
__320E01E0_corecrt_stdio_config@h DB 01H
__BAC7FC50_corecrt_wstdio@h DB 01H
__A3797CDC_stdio@h DB 01H
__BE076D93_corecrt_wio@h DB 01H
__CEEB45E5_corecrt_io@h DB 01H
__38B3600D_decryptdata_initial@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?decryptData@@YAHPADH@Z				; decryptData
PUBLIC	__JustMyCode_Default
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gkey@@3PAEA:BYTE				; gkey
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gPasswordHash@@3PAEA:BYTE			; gPasswordHash
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\travis\desktop\computer organization\project\2018 08 - cs 3843 - projectfiles4students\decryptdata_initial.cpp
;	COMDAT ?decryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?decryptData@@YAHPADH@Z PROC				; decryptData, COMDAT

; 11   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 12   : 	int resulti = 0;

	mov	DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

	mov	BYTE PTR ?gdebug1@@3EA, 0		; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

	mov	BYTE PTR ?gdebug2@@3EA, 0		; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   : 		// you will need to reference some of these global variables
; 24   : 		// (gptrPasswordHash or gPasswordHash), (gptrKey or gkey), gNumRounds
; 25   : 
; 26   : 		// simple example that xors 2nd byte of data with 14th byte in the key file
; 27   : 		lea esi,gkey				// put the ADDRESS of gkey into esi

	lea	esi, OFFSET ?gkey@@3PAEA

; 28   : 		mov esi,gptrKey;			// put the ADDRESS of gkey into esi (since *gptrKey = gkey)

	mov	esi, DWORD PTR ?gptrKey@@3PAEA		; gptrKey

; 29   : 
; 30   : 		lea	esi,gPasswordHash		// put ADDRESS of gPasswordHash into esi

	lea	esi, OFFSET ?gPasswordHash@@3PAEA

; 31   : 		mov esi,gptrPasswordHash	// put ADDRESS of gPasswordHash into esi (since unsigned char *gptrPasswordHash = gPasswordHash)

	mov	esi, DWORD PTR ?gptrPasswordHash@@3PAEA	; gptrPasswordHash

; 32   : 
; 33   : 		mov al,byte ptr [esi]				// get first byte of password hash

	mov	al, BYTE PTR [esi]

; 34   : 		mov al,byte ptr [esi+4]				// get 5th byte of password hash

	mov	al, BYTE PTR [esi+4]

; 35   : 		mov ebx,2

	mov	ebx, 2

; 36   : 		mov al,byte ptr [esi+ebx]			// get 3rd byte of password hash

	mov	al, BYTE PTR [esi+ebx]

; 37   : 		mov al,byte ptr [esi+ebx*2]			// get 5th byte of password hash

	mov	al, BYTE PTR [esi+ebx*2]

; 38   : 
; 39   : 		mov ax,word ptr [esi+ebx*2]			// gets 5th and 6th bytes of password hash ( gPasswordHash[4] and gPasswordHash[5] ) into ax

	mov	ax, WORD PTR [esi+ebx*2]

; 40   : 		mov eax,dword ptr [esi+ebx*2]		// gets 4 bytes, as in:  unsigned int X = *( (unsigned int*) &gPasswordHash[4] );

	mov	eax, DWORD PTR [esi+ebx*2]

; 41   : 
; 42   : 		mov al,byte ptr [gkey+ebx]			// get's 3rd byte of gkey[] data

	mov	al, BYTE PTR ?gkey@@3PAEA[ebx]

; 43   : 
; 44   : 		mov al,byte ptr [gptrKey+ebx]		// THIS IS INCORRECT - will add the address of the gptrKey global variable (NOT the value that gptrKey holds)

	mov	al, BYTE PTR ?gptrKey@@3PAEA[ebx]

; 45   : 
; 46   : 		mov al,byte ptr [esi+0xd];			// access 14th byte in gkey[]: 0, 1, 2 ... d is the 14th byte

	mov	al, BYTE PTR [esi+13]

; 47   : 		mov edi,data				// Put ADDRESS of first data element into edi

	mov	edi, DWORD PTR _data$[ebp]

; 48   : 		xor byte ptr [edi+1],al		// Exclusive-or the 2nd byte of data with the 14th element of the keyfile

	xor	BYTE PTR [edi+1], al

; 49   : 									// NOTE: Keyfile[14] = 0x21, that value changes the case of a letter and flips the LSB
; 50   : 									// Lowercase "c" = 0x63 becomes capital "B" since 0x63 xor 0x21 = 0x42
; 51   : 	}
; 52   : 
; 53   : 	return resulti;

	mov	eax, DWORD PTR _resulti$[ebp]

; 54   : } // decryptData

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?decryptData@@YAHPADH@Z ENDP				; decryptData
_TEXT	ENDS
END
